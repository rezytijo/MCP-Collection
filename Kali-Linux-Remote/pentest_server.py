#!/usr/bin/env python3
"""
Simple Penetration Test Playbook MCP Server - Runs penetration testing tools on Kali Linux VM via SSH with template support.
"""
import os
import sys
import logging
from datetime import datetime, timezone
import paramiko
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentest-server")

# Initialize MCP server - NO PROMPT PARAMETER!
mcp = FastMCP("pentest-playbook")

# Configuration
SSH_HOST = os.environ.get("SSH_HOST", "")
SSH_USER = os.environ.get("SSH_USER", "")
SSH_PASSWORD = os.environ.get("SSH_PASSWORD", "")
SSH_KEY_PATH = os.environ.get("SSH_KEY_PATH", "")

# === UTILITY FUNCTIONS ===
def sanitize_input(input_str: str) -> str:
    """Sanitize input to prevent command injection."""
    return input_str.replace(";", "").replace("&", "").replace("|", "").replace("`", "").strip()

def format_report(output: str, tool: str, target: str) -> str:
    """Format the tool output into a clean report with summary and full output."""
    lines = output.strip().split('\n')
    formatted = f"ğŸ” {tool.upper()} Report for {target}\n\n"
    formatted += "ğŸ“Š Summary (First 50 lines):\n"
    for line in lines[:50]:
        formatted += f"- {line}\n"
    if len(lines) > 50:
        formatted += "- ... (truncated for summary)\n"
    formatted += f"\nâœ… Scan completed. Total lines: {len(lines)}\n\n"
    formatted += "ğŸ“„ FULL RAW OUTPUT:\n"
    formatted += "=" * 50 + "\n"
    formatted += output
    formatted += "\n" + "=" * 50
    return formatted

def get_ssh_client():
    """Create and return authenticated SSH client."""
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    if SSH_KEY_PATH.strip():
        client.connect(SSH_HOST, username=SSH_USER, key_filename=SSH_KEY_PATH)
    else:
        client.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD)
    
    return client

@mcp.tool()
async def check_dependencies() -> str:
    """Check if all required penetration testing tools are installed on the Kali VM."""
    logger.info("Executing check_dependencies")
    
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    required_tools = [
        'whatweb', 'gobuster', 'nikto', 'nuclei', 'sqlmap', 
        'nmap', 'burpsuite', 'zaproxy', 'hydra', 'wpscan',
        'dirb', 'wfuzz', 'xsser', 'beef-xss', 'metasploit-framework'
    ]
    
    report = "ğŸ”§ DEPENDENCY CHECK REPORT\n\n"
    report += "ğŸ“‹ Required Tools:\n"
    
    try:
        client = get_ssh_client()
        
        for tool in required_tools:
            stdin, stdout, stderr = client.exec_command(f'which {tool}', timeout=10)
            output = stdout.read().decode().strip()
            if output:
                report += f"âœ… {tool}: Installed\n"
            else:
                report += f"âŒ {tool}: NOT FOUND\n"
        
        client.close()
        
        # Count installed vs missing
        installed = report.count("âœ…")
        missing = report.count("âŒ")
        
        report += f"\nğŸ“Š Summary: {installed} installed, {missing} missing\n"
        
        if missing > 0:
            report += "\nâš ï¸  Missing tools should be installed with: sudo apt update && sudo apt install <tool>\n"
        
        return report
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"
    """Run Nuclei tool on Kali VM with specified template and target."""
    logger.info(f"Executing run_nuclei_with_template with template={template}, target={target}")
    
    if not template.strip():
        return "âŒ Error: Template is required"
    if not target.strip():
        return "âŒ Error: Target is required"
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    sanitized_template = sanitize_input(template)
    sanitized_target = sanitize_input(target)
    
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        if SSH_KEY_PATH.strip():
            client.connect(SSH_HOST, username=SSH_USER, key_filename=SSH_KEY_PATH)
        else:
            if not SSH_PASSWORD.strip():
                return "âŒ Error: SSH_PASSWORD or SSH_KEY_PATH required"
            client.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD)
        
        command = f"nuclei -t {sanitized_template} -u {sanitized_target}"
        stdin, stdout, stderr = client.exec_command(command, timeout=300)
        
        output = stdout.read().decode('utf-8')
        error = stderr.read().decode('utf-8')
        exit_code = stdout.channel.recv_exit_status()
        
        client.close()
        
        if exit_code != 0:
            return f"âŒ Command failed with exit code {exit_code}: {error}"
        
        # Include stderr if present (e.g., info messages)
        full_output = output
        if error.strip():
            full_output += f"\nStderr: {error}"
        
        return format_report(full_output, "nuclei", sanitized_target)
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"

@mcp.tool()
async def run_nikto(target: str = "") -> str:
    """Run Nikto web server scanner on target URL."""
    logger.info(f"Executing run_nikto with target={target}")
    
    if not target.strip():
        return "âŒ Error: Target URL is required"
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    sanitized_target = sanitize_input(target)
    
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        if SSH_KEY_PATH.strip():
            client.connect(SSH_HOST, username=SSH_USER, key_filename=SSH_KEY_PATH)
        else:
            if not SSH_PASSWORD.strip():
                return "âŒ Error: SSH_PASSWORD or SSH_KEY_PATH required"
            client.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD)
        
        command = f"nikto -h {sanitized_target}"
        stdin, stdout, stderr = client.exec_command(command, timeout=600)  # Nikto can take longer
        
        output = stdout.read().decode('utf-8')
        error = stderr.read().decode('utf-8')
        exit_code = stdout.channel.recv_exit_status()
        
        client.close()
        
        if exit_code != 0:
            return f"âŒ Command failed with exit code {exit_code}: {error}"
        
        full_output = output
        if error.strip():
            full_output += f"\nStderr: {error}"
        
        return format_report(full_output, "nikto", sanitized_target)
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"

@mcp.tool()
async def run_sqlmap(url: str = "", options: str = "") -> str:
    """Run SQLMap on target URL with additional options."""
    logger.info(f"Executing run_sqlmap with url={url}, options={options}")
    
    if not url.strip():
        return "âŒ Error: URL is required"
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    sanitized_url = sanitize_input(url)
    sanitized_options = sanitize_input(options)
    
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        if SSH_KEY_PATH.strip():
            client.connect(SSH_HOST, username=SSH_USER, key_filename=SSH_KEY_PATH)
        else:
            if not SSH_PASSWORD.strip():
                return "âŒ Error: SSH_PASSWORD or SSH_KEY_PATH required"
            client.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD)
        
        command = f"sqlmap -u {sanitized_url} --batch {sanitized_options}"
        stdin, stdout, stderr = client.exec_command(command, timeout=900)  # SQLMap can take long
        
        output = stdout.read().decode('utf-8')
        error = stderr.read().decode('utf-8')
        exit_code = stdout.channel.recv_exit_status()
        
        client.close()
        
        if exit_code != 0:
            return f"âŒ Command failed with exit code {exit_code}: {error}"
        
        full_output = output
        if error.strip():
            full_output += f"\nStderr: {error}"
        
        return format_report(full_output, "sqlmap", sanitized_url)
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"

@mcp.tool()
async def run_nmap(target: str = "", options: str = "-sV -p-") -> str:
    """Run Nmap port scanner on target with specified options."""
    logger.info(f"Executing run_nmap with target={target}, options={options}")
    
    if not target.strip():
        return "âŒ Error: Target is required"
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    sanitized_target = sanitize_input(target)
    sanitized_options = sanitize_input(options)
    
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        if SSH_KEY_PATH.strip():
            client.connect(SSH_HOST, username=SSH_USER, key_filename=SSH_KEY_PATH)
        else:
            if not SSH_PASSWORD.strip():
                return "âŒ Error: SSH_PASSWORD or SSH_KEY_PATH required"
            client.connect(SSH_HOST, username=SSH_USER, password=SSH_PASSWORD)
        
        command = f"nmap {sanitized_options} {sanitized_target}"
        stdin, stdout, stderr = client.exec_command(command, timeout=600)  # Nmap can take time
        
        output = stdout.read().decode('utf-8')
        error = stderr.read().decode('utf-8')
        exit_code = stdout.channel.recv_exit_status()
        
        client.close()
        
        if exit_code != 0:
            return f"âŒ Command failed with exit code {exit_code}: {error}"
        
        full_output = output
        if error.strip():
            full_output += f"\nStderr: {error}"
        
        return format_report(full_output, "nmap", sanitized_target)
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"

@mcp.tool()
async def run_web_pentest_playbook(target: str = "") -> str:
    """Run comprehensive web penetration testing playbook on target URL."""
    logger.info(f"Executing run_web_pentest_playbook with target={target}")
    
    if not target.strip():
        return "âŒ Error: Target URL is required"
    if not SSH_HOST.strip() or not SSH_USER.strip():
        return "âŒ Error: SSH configuration missing (SSH_HOST, SSH_USER required)"
    
    sanitized_target = sanitize_input(target)
    
    report = f"ğŸ” WEB PENETRATION TESTING PLAYBOOK REPORT\n"
    report += f"ğŸ¯ Target: {sanitized_target}\n"
    report += f"ğŸ“… Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    
    try:
        # Phase 1: Planning (Note: This is informational)
        report += "ğŸ“‹ PHASE 1: PLANNING\n"
        report += "âœ… Methodology: Black Box Testing\n"
        report += "âœ… Scope: Web application assessment\n"
        report += "âœ… Rules: Non-destructive testing only\n\n"
        
        # Phase 2: Information Gathering
        report += "ğŸ” PHASE 2: INFORMATION GATHERING\n"
        
        # WhatWeb for technology detection
        try:
            client = get_ssh_client()
            stdin, stdout, stderr = client.exec_command(f"whatweb {sanitized_target}", timeout=60)
            whatweb_output = stdout.read().decode('utf-8')
            whatweb_error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            client.close()
            if exit_code == 0:
                report += f"ğŸ“Š Technology Detection (WhatWeb):\n{whatweb_output}\n"
                if whatweb_error.strip():
                    report += f"Stderr: {whatweb_error}\n"
            else:
                report += f"âš ï¸ WhatWeb failed: {whatweb_error}\n"
        except Exception as e:
            report += f"âš ï¸ WhatWeb error: {str(e)}\n"
        
        # Gobuster for directory enumeration (quick scan)
        try:
            client = get_ssh_client()
            stdin, stdout, stderr = client.exec_command(f"gobuster dir -u {sanitized_target} -w /usr/share/wordlists/dirb/common.txt -t 10 -q", timeout=120)
            gobuster_output = stdout.read().decode('utf-8')
            gobuster_error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            client.close()
            if exit_code == 0 and gobuster_output.strip():
                report += f"ğŸ“ Directory Enumeration (Gobuster):\n{gobuster_output}\n"
                if gobuster_error.strip():
                    report += f"Stderr: {gobuster_error}\n"
            else:
                report += f"ğŸ“ Directory Enumeration: No significant findings or failed\n"
                if gobuster_error.strip():
                    report += f"Error: {gobuster_error}\n"
        except Exception as e:
            report += f"âš ï¸ Gobuster error: {str(e)}\n"
        
        # Phase 3: Scanning & Vulnerability Analysis
        report += "ğŸ” PHASE 3: SCANNING & VULNERABILITY ANALYSIS\n"
        
        # Nikto scan
        try:
            client = get_ssh_client()
            stdin, stdout, stderr = client.exec_command(f"nikto -h {sanitized_target} -Tuning x", timeout=300)
            nikto_output = stdout.read().decode('utf-8')
            nikto_error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            client.close()
            if exit_code == 0:
                report += f"ğŸŒ Web Server Scan (Nikto):\n{nikto_output}\n"
                if nikto_error.strip():
                    report += f"Stderr: {nikto_error}\n"
            else:
                report += f"âš ï¸ Nikto failed: {nikto_error}\n"
        except Exception as e:
            report += f"âš ï¸ Nikto error: {str(e)}\n"
        
        # Nuclei scan with common templates
        try:
            client = get_ssh_client()
            stdin, stdout, stderr = client.exec_command(f"nuclei -u {sanitized_target} -t technologies/ -t vulnerabilities/ -t exposures/ -severity info,low,medium,high,critical -silent", timeout=300)
            nuclei_output = stdout.read().decode('utf-8')
            nuclei_error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            client.close()
            if exit_code == 0 and nuclei_output.strip():
                report += f"ğŸ¯ Vulnerability Scan (Nuclei):\n{nuclei_output}\n"
                if nuclei_error.strip():
                    report += f"Stderr: {nuclei_error}\n"
            else:
                report += f"ğŸ¯ Vulnerability Scan: No vulnerabilities found or scan failed\n"
                if nuclei_error.strip():
                    report += f"Error: {nuclei_error}\n"
        except Exception as e:
            report += f"âš ï¸ Nuclei error: {str(e)}\n"
        
        # Phase 4: Exploitation (Basic SQL Injection check)
        report += "ğŸ’¥ PHASE 4: EXPLOITATION\n"
        
        # Quick SQLMap check
        try:
            client = get_ssh_client()
            stdin, stdout, stderr = client.exec_command(f"sqlmap -u {sanitized_target} --batch --level 1 --risk 1", timeout=600)
            sqlmap_output = stdout.read().decode('utf-8')
            sqlmap_error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            client.close()
            if exit_code == 0 and "Parameter:" in sqlmap_output:
                report += f"ğŸ’‰ SQL Injection Test (SQLMap):\n{sqlmap_output}\n"
                if sqlmap_error.strip():
                    report += f"Stderr: {sqlmap_error}\n"
            else:
                report += f"ğŸ’‰ SQL Injection Test: No injection points found\n"
                if sqlmap_error.strip():
                    report += f"Error: {sqlmap_error}\n"
        except Exception as e:
            report += f"âš ï¸ SQLMap error: {str(e)}\n"
        
        # Phase 5: Reporting
        report += "ğŸ“„ PHASE 5: REPORTING\n"
        report += "âœ… Comprehensive report generated above\n"
        report += "ğŸ“‹ Recommendations:\n"
        report += "- Review and fix identified vulnerabilities\n"
        report += "- Implement security headers\n"
        report += "- Regular security assessments\n"
        report += "- Keep software updated\n\n"
        
        # Phase 6: Remediation & Retesting
        report += "ğŸ”„ PHASE 6: REMEDIATION & RETESTING\n"
        report += "ğŸ“ After implementing fixes, re-run this playbook to verify remediation\n"
        report += "ğŸ” Retesting ensures vulnerabilities are properly addressed\n"
        
        return report
    
    except paramiko.AuthenticationException:
        return "âŒ Error: SSH authentication failed"
    except paramiko.SSHException as e:
        return f"âŒ Error: SSH connection failed: {str(e)}"
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"âŒ Error: {str(e)}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Penetration Test Playbook MCP server...")
    
    if not SSH_HOST or not SSH_USER:
        logger.warning("SSH_HOST and SSH_USER environment variables not set")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)