#!/usr/bin/env python3
"""
Penetration Testing MCP Server - Security testing tools for personal lab environments
"""
import os
import sys
import logging
import subprocess
import re
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentest-server")

# Initialize MCP server
mcp = FastMCP("pentest")

# Configuration
MAX_OUTPUT_LENGTH = int(os.environ.get("MAX_OUTPUT_LENGTH", "10000"))

# === UTILITY FUNCTIONS ===

def sanitize_input(input_str: str) -> str:
    """Remove potentially dangerous characters from input."""
    # Allow alphanumeric, dots, hyphens, slashes, colons, underscores
    return re.sub(r'[^a-zA-Z0-9.\-/:_,]', '', input_str)

def truncate_output(output: str, max_length: int = MAX_OUTPUT_LENGTH) -> str:
    """Truncate output if too long."""
    if len(output) > max_length:
        return output[:max_length] + f"\n\n... [Output truncated at {max_length} characters]"
    return output

def run_command(command: list, timeout: int = 300) -> str:
    """Execute a command and return formatted output."""
    try:
        logger.info(f"Executing command: {' '.join(command)}")
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        output = result.stdout if result.stdout else result.stderr
        
        if result.returncode == 0:
            return f"‚úÖ Command completed successfully:\n\n{truncate_output(output)}"
        else:
            return f"‚ö†Ô∏è Command completed with warnings:\n\nReturn code: {result.returncode}\n\n{truncate_output(output)}"
            
    except subprocess.TimeoutExpired:
        return f"‚è±Ô∏è Command timed out after {timeout} seconds"
    except Exception as e:
        logger.error(f"Command execution error: {e}")
        return f"‚ùå Error executing command: {str(e)}"

# === MCP TOOLS ===

@mcp.tool()
async def nmap_scan(target: str = "", scan_type: str = "basic", ports: str = "") -> str:
    """Perform network reconnaissance scan using nmap on specified target with various scan types."""
    if not target.strip():
        return "‚ùå Error: Target IP or hostname is required"
    
    target = sanitize_input(target)
    scan_type = scan_type.lower().strip()
    
    # Build nmap command based on scan type
    if scan_type == "basic":
        cmd = ["nmap", "-sV", target]
    elif scan_type == "fast":
        cmd = ["nmap", "-F", target]
    elif scan_type == "intense":
        cmd = ["nmap", "-A", "-T4", target]
    elif scan_type == "stealth":
        cmd = ["nmap", "-sS", "-T2", target]
    elif scan_type == "udp":
        cmd = ["nmap", "-sU", target]
    elif scan_type == "os":
        cmd = ["nmap", "-O", target]
    else:
        cmd = ["nmap", target]
    
    # Add port specification if provided
    if ports.strip():
        ports = sanitize_input(ports)
        cmd.extend(["-p", ports])
    
    return run_command(cmd, timeout=600)

@mcp.tool()
async def nikto_scan(target: str = "", port: str = "80", ssl: str = "no") -> str:
    """Scan web server for vulnerabilities and misconfigurations using nikto."""
    if not target.strip():
        return "‚ùå Error: Target URL or hostname is required"
    
    target = sanitize_input(target)
    port = sanitize_input(port) if port.strip() else "80"
    
    cmd = ["nikto", "-h", target, "-p", port]
    
    if ssl.lower().strip() == "yes":
        cmd.append("-ssl")
    
    return run_command(cmd, timeout=900)

@mcp.tool()
async def sqlmap_scan(url: str = "", data: str = "", cookie: str = "") -> str:
    """Test web application for SQL injection vulnerabilities using sqlmap."""
    if not url.strip():
        return "‚ùå Error: Target URL is required"
    
    cmd = ["sqlmap", "-u", url, "--batch", "--level=1", "--risk=1"]
    
    if data.strip():
        cmd.extend(["--data", data])
    
    if cookie.strip():
        cmd.extend(["--cookie", cookie])
    
    return run_command(cmd, timeout=1200)

@mcp.tool()
async def wpscan_scan(url: str = "", enumerate: str = "vp") -> str:
    """Scan WordPress site for vulnerabilities and enumerate users plugins themes."""
    if not url.strip():
        return "‚ùå Error: Target WordPress URL is required"
    
    enumerate = enumerate.strip() if enumerate.strip() else "vp"
    
    cmd = ["wpscan", "--url", url, "--enumerate", enumerate, "--random-user-agent"]
    
    api_token = os.environ.get("WPSCAN_API_TOKEN", "")
    if api_token:
        cmd.extend(["--api-token", api_token])
    
    return run_command(cmd, timeout=900)

@mcp.tool()
async def dirb_scan(url: str = "", wordlist: str = "") -> str:
    """Perform directory and file brute force discovery on web server."""
    if not url.strip():
        return "‚ùå Error: Target URL is required"
    
    if not wordlist.strip():
        wordlist = "/usr/share/dirb/wordlists/common.txt"
    
    cmd = ["dirb", url, wordlist, "-S"]
    
    return run_command(cmd, timeout=900)

@mcp.tool()
async def searchsploit_query(search_term: str = "", exact: str = "no") -> str:
    """Search ExploitDB database for known exploits and vulnerabilities."""
    if not search_term.strip():
        return "‚ùå Error: Search term is required"
    
    cmd = ["searchsploit", search_term]
    
    if exact.lower().strip() == "yes":
        cmd.append("-e")
    
    return run_command(cmd, timeout=60)

@mcp.tool()
async def dns_enum(domain: str = "") -> str:
    """Perform DNS enumeration and gather domain information using dig and host."""
    if not domain.strip():
        return "‚ùå Error: Domain name is required"
    
    domain = sanitize_input(domain)
    
    results = []
    
    # A record
    results.append("üîç A Records:")
    results.append(run_command(["dig", "+short", "A", domain], timeout=30))
    
    # MX record
    results.append("\nüìß MX Records:")
    results.append(run_command(["dig", "+short", "MX", domain], timeout=30))
    
    # NS record
    results.append("\nüåê NS Records:")
    results.append(run_command(["dig", "+short", "NS", domain], timeout=30))
    
    # TXT record
    results.append("\nüìù TXT Records:")
    results.append(run_command(["dig", "+short", "TXT", domain], timeout=30))
    
    return "\n".join(results)

@mcp.tool()
async def whois_lookup(domain: str = "") -> str:
    """Perform WHOIS lookup to gather domain registration information."""
    if not domain.strip():
        return "‚ùå Error: Domain name is required"
    
    domain = sanitize_input(domain)
    
    return run_command(["whois", domain], timeout=60)

@mcp.tool()
async def port_knock(target: str = "", ports: str = "") -> str:
    """Perform TCP port knocking sequence on target host."""
    if not target.strip():
        return "‚ùå Error: Target IP or hostname is required"
    
    if not ports.strip():
        return "‚ùå Error: Port sequence is required (comma-separated)"
    
    target = sanitize_input(target)
    port_list = [p.strip() for p in ports.split(",")]
    
    results = [f"üö™ Knocking on {target} with sequence: {ports}"]
    
    for port in port_list:
        try:
            result = subprocess.run(
                ["timeout", "1", "bash", "-c", f"echo > /dev/tcp/{target}/{port}"],
                capture_output=True,
                text=True
            )
            results.append(f"  ‚úì Knocked port {port}")
        except Exception as e:
            results.append(f"  ‚úó Failed port {port}: {str(e)}")
    
    return "\n".join(results)

@mcp.tool()
async def custom_command(tool: str = "", args: str = "") -> str:
    """Execute custom security tool command with specified arguments."""
    if not tool.strip():
        return "‚ùå Error: Tool name is required"
    
    allowed_tools = ["nmap", "nikto", "sqlmap", "wpscan", "dirb", "searchsploit", "dig", "whois", "curl", "wget"]
    
    tool = tool.strip().lower()
    if tool not in allowed_tools:
        return f"‚ùå Error: Tool must be one of: {', '.join(allowed_tools)}"
    
    cmd = [tool]
    if args.strip():
        cmd.extend(args.split())
    
    return run_command(cmd, timeout=600)

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Penetration Testing MCP server...")
    logger.warning("‚ö†Ô∏è  This server provides access to offensive security tools")
    logger.warning("‚ö†Ô∏è  Use only on systems you own or have explicit permission to test")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)